VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "aShadow"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
'*************************************************************************************************
'* cShadow - cSelfSub based sample that creates a form shadow.
'*
'* Note: because this sample will likely be used in the wild as-is, I've commented out the unused
'*  subclass procedures, sc_DelMsg, sc_CallOrigWndProc and the sc_lParamUser property
'*
'* Paul_Caton@hotmail.com
'* Copyright free, use and abuse as you see fit.
'*
'* v1.0 Re-write of the SelfSub/WinSubHook-2 submission to Planet Source Code............ 20060322
'* v1.1 Shadow color property added...................................................... 20060406
'* v1.2 把阴影优化成四周阴影 咱干的是没啥技术含量的活，向牛叉的原作者致敬！ akebe  136775565
'* v1.3 把阴影优化成可以给多个窗口应用，向牛叉的原作者致敬 too！ Error 404 1361778219
'*************************************************************************************************

Option Explicit

'-Selfsub declarations----------------------------------------------------------------------------
Private Enum eMsgWhen                                                           'When to callback什么时候回调
    MSG_BEFORE = 1                                                              'Callback before the original WndProc回调之前最初的指向
    MSG_AFTER = 2                                                               'Callback after the original WndProc回调后原来的指向
    MSG_BEFORE_AFTER = MSG_BEFORE Or MSG_AFTER                                  'Callback before and after the original WndProc回调之前和之后原来的指向
End Enum

Private Const ALL_MESSAGES  As Long = -1                                        'All messages callback所有消息回调
Private Const MSG_ENTRIES   As Long = 32                                        'Number of msg table entries味精表条目的数量
Private Const WNDPROC_OFF   As Long = &H38                                      'Thunk offset to the WndProc execution address 铛抵消指向执行地址
Private Const GWL_WNDPROC   As Long = -4                                        'SetWindowsLong WndProc index SetWindowsLong指向索引
Private Const IDX_SHUTDOWN  As Long = 1                                         'Thunk data index of the shutdown flag 铛数据索引的关闭标记
Private Const IDX_HWND      As Long = 2                                         'Thunk data index of the subclassed hWnd 铛hWnd子类化指数的数据
Private Const IDX_WNDPROC   As Long = 9                                         'Thunk data index of the original WndProc 铛数据指数最初的指向
Private Const IDX_BTABLE    As Long = 11                                        'Thunk data index of the Before table铛数据在表的索引
Private Const IDX_ATABLE    As Long = 12                                        'Thunk data index of the After table 铛后的数据索引表
Private Const IDX_PARM_USER As Long = 13                                        'Thunk data index of the User-defined callback parameter data index铛数据索引定义的回调参数数据的索引

Private z_ScMem             As Long                                             'Thunk base address 铛基地址
Private z_Sc(64)            As Long                                             'Thunk machine-code initialised here 铛机器码这里初始化的
Private z_Funk              As Collection                                       'hWnd/thunk-address collection hWnd / thunk-address集合

Private Declare Function CallWindowProcA Lib "user32" (ByVal lpPrevWndFunc As Long, ByVal Hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
Private Declare Function GetModuleHandleA Lib "kernel32" (ByVal lpModuleName As String) As Long
Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long
Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal Hwnd As Long, lpdwProcessId As Long) As Long
Private Declare Function IsBadCodePtr Lib "kernel32" (ByVal lpfn As Long) As Long
Private Declare Function IsWindow Lib "user32" (ByVal Hwnd As Long) As Long
Private Declare Function SetWindowLongA Lib "user32" (ByVal Hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function VirtualAlloc Lib "kernel32" (ByVal lpAddress As Long, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long
Private Declare Function VirtualFree Lib "kernel32" (ByVal lpAddress As Long, ByVal dwSize As Long, ByVal dwFreeType As Long) As Long
Private Declare Sub RtlMoveMemory Lib "kernel32" (ByVal Destination As Long, ByVal Source As Long, ByVal length As Long)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Private Const DEF_COLOR             As Long = 0
Private Const DEF_DEPTH             As Long = 7
Private Const DEF_TRANSPARENCY      As Long = 140

Private Const AC_SRC_OVER           As Long = &H0
Private Const AC_SRC_ALPHA          As Long = &H1
Private Const BITSPIXEL             As Long = 12
Private Const SIZE_RESTORED         As Long = 0
Private Const SW_HIDE               As Long = 0
Private Const SW_SHOWNOACTIVATE     As Long = 4
Private Const SWP_HIDEWINDOW        As Long = &H80
Private Const SWP_SHOWWINDOW        As Long = &H40
Private Const ULW_ALPHA             As Long = &H2

Private Const WM_MDIACTIVATE        As Long = &H222
Private Const WM_DISPLAYCHANGE      As Long = &H7E
Private Const WM_THEMECHANGED       As Long = &H31A
Private Const WM_WINDOWPOSCHANGED   As Long = &H47
Private Const WM_SIZE               As Long = &H5
Private Const WS_EX_LAYERED         As Long = &H80000
Private Const WS_EX_NOPARENTNOTIFY  As Long = &H4
Private Const WS_EX_TRANSPARENT     As Long = &H20
Private Const WS_POPUP              As Long = &H80000000

Private Type tBGRA
    Blue                            As Byte
    Green                           As Byte
    Red                             As Byte
    Alpha                           As Byte
End Type

Private Type tBITMAPINFOHEADER
    biSize                            As Long
    biWidth                           As Long
    biHeight                          As Long
    biPlanes                          As Integer
    biBitCount                        As Integer
    biCompression                     As Long
    biSizeImage                       As Long
    biXPelsPerMeter                   As Long
    biYPelsPerMeter                   As Long
    biClrUsed                         As Long
    biClrImportant                    As Long
End Type

Private Type tBLENDFUNCTION
    BlendOp                           As Byte
    BlendFlags                        As Byte
    SourceConstantAlpha               As Byte
    AlphaFormat                       As Byte
End Type

Private Type tOSVERSIONINFO
    dwOSVersionInfoSize               As Long
    dwMajorVersion                    As Long
    dwMinorVersion                    As Long
    dwBuildNumber                     As Long
    dwPlatformId                      As Long
    szCSDVersion                      As String * 128
End Type

Private Type tPOINT
    X                                 As Long
    Y                                 As Long
End Type

Private Type tRECT
    Left                              As Long
    top                               As Long
    Right                             As Long
    Bottom                            As Long
End Type

Private Type tSAFEARRAYBOUND
    cElements                         As Long
    lLbound                           As Long
End Type

Private Type tSAFEARRAY2D
    cDims                             As Integer
    fFeatures                         As Integer
    cbElements                        As Long
    cLocks                            As Long
    pvData                            As Long
    Bounds(0 To 1)                    As tSAFEARRAYBOUND
End Type



Private Type tSIZE
    cx                                As Long
    cy                                As Long
End Type

Private Type tWINDOWPOS
    Hwnd                              As Long
    hWndInsertAfter                   As Long
    X                                 As Long
    Y                                 As Long
    cx                                As Long
    cy                                As Long
    flags                             As Long
End Type

Private m_Color                     As Long                                     'Private shadow color property value私有阴影颜色属性值
Private m_Depth                     As Long                                     'Private shadow depth property value私有阴影深度属性值
Private m_Transparency              As Long                                     'Private shadow transparency property value私有阴影透明属性值

Private bIsLayered                  As Boolean                                  'Layered windows supported布尔的分层窗口支持
Private bIsLuna                     As Boolean                                  'Luna theme? 布尔
Private bIsXP                       As Boolean                                  'Windows XP?布尔的Windows XP吗
Private bLastShow                   As Boolean                                  'The previous show state布尔之前的显示状态
Private cx                          As Long                                     'Width 宽度
Private cy                          As Long                                     'Height 高度
Private hWndBt                      As Long                                     'Bottom shadow window handle 底影子窗口句柄
Private hWndRt                      As Long                                     'Right shadow window handle 正确的影子窗口句柄
Private hWndTt                      As Long                                     '上面的阴影（akebe）
Private hWndLt                      As Long                                     '坐标的阴影（akebe）
Private hWndForm                    As Long                                     'Parent window handle 父窗口句柄
Private wp                          As tWINDOWPOS                               'Parent window position 父窗口的位置

Private Declare Function CreateDIBSection Lib "gdi32" (ByVal hdc As Long, pBitmapInfo As tBITMAPINFOHEADER, ByVal un As Long, ByRef lplpVoid As Long, ByVal handle As Long, ByVal dw As Long) As Long
Private Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As Long) As Long
Private Declare Function CreateWindowExA Lib "user32" (ByVal dwExStyle As Long, ByVal lpClassName As String, ByVal lpWindowName As String, ByVal dwStyle As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As Long, ByVal hMenu As Long, ByVal hInstance As Long, lpParam As Any) As Long
Private Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Private Declare Function DestroyWindow Lib "user32" (ByVal Hwnd As Long) As Long
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function GetCurrentThemeName Lib "uxtheme.dll" (ByVal pszThemeFileName As Long, ByVal cchMaxNameChars As Long, ByVal pszColorBuff As Long, ByVal cchMaxColorChars As Long, ByVal pszSizeBuff As Long, ByVal cchMaxSizeChars As Long) As Long
Private Declare Function GetDC Lib "user32" (ByVal Hwnd As Long) As Long
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Private Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function GetThemeDocumentationProperty Lib "uxtheme.dll" (ByVal pszThemeName As Long, ByVal pszPropertyName As Long, ByVal pszValueBuff As Long, ByVal cchMaxValChars As Long) As Long
Private Declare Function GetVersionExA Lib "kernel32" (lpVersionInformation As tOSVERSIONINFO) As Long
Private Declare Function IsWindowVisible Lib "user32" (ByVal Hwnd As Long) As Long
Private Declare Function LoadLibraryA Lib "kernel32" (ByVal lpLibFileName As String) As Long
Private Declare Function MoveWindow Lib "user32" (ByVal Hwnd As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Private Declare Function ShowWindow Lib "user32" (ByVal Hwnd As Long, ByVal nCmdShow As Long) As Long
Private Declare Function UpdateLayeredWindow Lib "user32.dll" (ByVal Hwnd As Long, ByVal hdcDest As Long, ptDst As Any, pSize As Any, ByVal hdcSrc As Long, ptSrc As Any, ByVal crKey As Long, pBlend As Any, ByVal dwFlags As Long) As Long
Private Declare Function VarPtrArray Lib "msvbvm60.dll" Alias "VarPtr" (ptr() As Any) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal length As Long)


Private Sub Class_Initialize()                                                  'Class initialization 类初始化
    CheckEnvironment
    m_Depth = DEF_DEPTH
    m_Transparency = DEF_TRANSPARENCY
End Sub

Private Sub Class_Terminate()
    sc_Terminate                                                                'Terminate all subclassing 终止所有子类化
    
    If hWndRt <> 0 Then
        DestroyWindow hWndRt
        DestroyWindow hWndBt
        DestroyWindow hWndLt                                                    '(akebe)
        DestroyWindow hWndTt                                                    '(akebe)
    End If
End Sub

'Shadow depth property
Public Property Get Color() As Long
    Color = m_Color
End Property
'
Public Property Let Color(ByVal NewValue As Long)
    Const COLOR_SYS_MASK As Long = &H80000000
    
    If (NewValue And COLOR_SYS_MASK) Then                                       'If the system color bit is set 如果系统已经设置了颜色位
        NewValue = GetSysColor(NewValue Xor COLOR_SYS_MASK)                     'Get the translated system color 得到颜色的翻译系统
    End If
    
    If NewValue <> m_Color Then
        m_Color = NewValue
        DisplayShadows
    End If
End Property

'Shadow depth property 阴影深度属性
Public Property Get Depth() As Long
    Depth = m_Depth
End Property
'
Public Property Let Depth(ByVal NewValue As Long)
    If NewValue <> m_Depth Then
        m_Depth = NewValue
        DisplayShadows
    End If
End Property

'Shadow transparency property 影子透明属性
Public Property Get Transparency() As Byte
    Transparency = CByte(m_Transparency)
End Property
'
Public Property Let Transparency(ByVal NewValue As Byte)
    If NewValue <> m_Transparency Then
        m_Transparency = CLng(NewValue)
        DisplayShadows
    End If
End Property

'Set the form to be shadowed设置表单阴影
Public Function Shadow(frm As Form) As Boolean
    If hWndForm <> 0 Then
        zError "Shadow", "Only a single form per cShadow instance is allowed"
        Exit Function
    End If
    
    If bIsLayered Then
        hWndForm = frm.Hwnd
        
        If sc_Subclass(hWndForm) Then
            sc_AddMsg hWndForm, WM_WINDOWPOSCHANGED, MSG_BEFORE                 '这个要是不执行就不行了
            sc_AddMsg hWndForm, WM_SIZE, MSG_BEFORE
            sc_AddMsg hWndForm, WM_DISPLAYCHANGE, MSG_BEFORE
            
            If bIsXP Then
                sc_AddMsg hWndForm, WM_THEMECHANGED, MSG_BEFORE
            End If
            
            CreateWindows
            Shadow = True
        End If
    End If
End Function

'Validate the OS and color depth 验证操作系统和颜色深度
Private Sub CheckEnvironment()
    Dim OSV As tOSVERSIONINFO
    
    bIsLayered = False
    
    With OSV
        .dwOSVersionInfoSize = Len(OSV)                                         'Set the length element 设置长度元素
        GetVersionExA OSV                                                       'Fill the type with OS version info 填满类型操作系统的版本信息
        
        
        If .dwMajorVersion >= 5 Then                                            'If the major version is 5 or greater then the OS supports transparency 如果主要版本5或更高然后操作系统支持透明度
            bIsLayered = True
            
            If .dwMinorVersion > 0 Then
                bIsXP = True                                                    'Assume luna window shape, if people like this control enough i'll access the theme api's to get the actual window shape.
                bIsLuna = IsLuna                                                '假设luna窗口形状,如果人们喜欢这种控制足够我将访问api的主题来获得实际的窗口的形状
            End If
            
            bIsLayered = (GetDeviceCaps(GetDC(0), BITSPIXEL) >= 16)             'Ensure we have enough screen colors确保我们有足够的屏幕颜色
        End If
    End With
End Sub




'Create the shadow windows 创建影子窗口
Private Sub CreateWindows()
    Const EX_STYLE As Long = WS_EX_LAYERED Or WS_EX_TRANSPARENT Or WS_EX_NOPARENTNOTIFY
    
    hWndRt = CreateWindowExA(EX_STYLE, "#32770", vbNullString, WS_POPUP, 0, 0, 0, 0, hWndForm, 0, App.hInstance, 0)
    hWndBt = CreateWindowExA(EX_STYLE, "#32770", vbNullString, WS_POPUP, 0, 0, 0, 0, hWndForm, 0, App.hInstance, 0)
    
    hWndTt = CreateWindowExA(EX_STYLE, "#32770", vbNullString, WS_POPUP, 0, 0, 0, 0, hWndForm, 0, App.hInstance, 0) '(akebe)
    hWndLt = CreateWindowExA(EX_STYLE, "#32770", vbNullString, WS_POPUP, 0, 0, 0, 0, hWndForm, 0, App.hInstance, 0) '(akebe)
End Sub

'Display the right and bottom shadows 显示右边和底部的阴影
Private Sub DisplayShadows()
    If bIsLayered Then
        If IsWindowVisible(hWndForm) <> 0 Then
            With wp
                DisplayShadowSub .X + .cx, .Y, m_Depth, .cy + m_Depth + m_Depth, 1 '创建窗体大小的阴影(1右)akebe调整
                DisplayShadowSub .X + .cx, .Y, m_Depth, .cy + m_Depth + m_Depth, 3 '创建窗体大小的阴影(3左)akebe添加
                DisplayShadowSub .X, .Y + .cy, .cx + m_Depth, m_Depth, 2        '创建窗体大小的阴影(2下)akebe调整
                DisplayShadowSub .X, .Y + .cy, .cx + m_Depth, m_Depth, 4        '创建窗体大小的阴影(4上)akebe添加
            End With
        End If
    End If
End Sub

'Display the content of the specified shadow window 显示指定的影子窗口的内容（把只有2个值的bRight改成Integer可以支持多个值 akebe）
Private Sub DisplayShadowSub(ByVal X As Long, ByVal Y As Long, cx As Long, cy As Long, ByVal bRight As Integer)
    Dim DC        As Long
    Dim iX        As Long
    Dim iY        As Long
    Dim hDib      As Long
    Dim hWin      As Long
    Dim nAlpha    As Long
    Dim aPixels() As Long
    Dim pBmpBits  As Long
    Dim pt0       As tPOINT
    Dim pt        As tPOINT
    Dim sz        As tSIZE
    Dim bs        As tBLENDFUNCTION
    Dim bmpHeader As tBITMAPINFOHEADER
    Dim SafeArray As tSAFEARRAY2D
    
    DC = CreateCompatibleDC(0)                                                  'Get a screen compatible memory dc 得到一个屏幕兼容的内存
    
    With bmpHeader                                                              'Initialize a bitmap header 初始化一个位图标题
        .biSize = Len(bmpHeader)                                                'Bitmap header size位图头大小
        .biWidth = cx                                                           'Bitmap/window pixel width 位图像素宽度/窗口
        .biHeight = cy                                                          'Bitmap/window pixel height 位图像素高度/窗口
        .biPlanes = 1                                                           'Graphics planes 图形的飞机
        .biBitCount = 32                                                        '32bits per pixel BGRA (Blue, Green, Red, Alpha) 32比特每像素BGRA(蓝、绿、红、α)
        .biSizeImage = cx * cy * 4                                              'Memory size, width * height * 32bit 内存大小、宽*高* 32位
    End With
    
    hDib = CreateDIBSection(DC, bmpHeader, 0, pBmpBits, 0, 0)                   'Create a device independant bitmap as per the header, compatible with the dc (compatible with the screen)
    '创建一个设备独立位图按头,兼容直流(兼容的屏幕)
    With SafeArray                                                              'Construct a VB safearray header that matches the specs of the bitmap 构造一个VB safearray头规格相匹配的位图
        .cbElements = 4                                                         '4 bytes per element - 32bits per pixel 4个字节每个元素――32位/像素
        .cDims = 2                                                              'We'll treat the pixels as a two dimensional (x, y) array 我们将把像素作为一个二维数组(x,y)
        .pvData = pBmpBits                                                      'The data pointer points to the bitmap data (pixels) 指针指向的数据位图数据(像素)
        .Bounds(0).lLbound = 0                                                  'Lowest bound will be 0 最低为0
        .Bounds(0).cElements = cy                                               'The number of elements元素的数量
        .Bounds(1).lLbound = 0                                                  'Lowest bound will be 0 最低为0
        .Bounds(1).cElements = cx                                               'The number of elements 元素的数量
    End With
    
    CopyMemory ByVal VarPtrArray(aPixels()), VarPtr(SafeArray), 4               'Copy the address of our safearray over the address of aPixels() safearray 复制我们的safearray aPixels的地址的地址()safearray
    
    If bRight = 1 Then hWin = hWndRt
    If bRight = 2 Then hWin = hWndBt
    If bRight = 3 Then hWin = hWndTt
    If bRight = 4 Then hWin = hWndLt
    
    If bRight = 1 Then                                                          'akebe调整
        For iY = 0 To cy - 1
            If iY < cx Then
                nAlpha = (255 * iY) \ cx
            ElseIf iY >= (cy - cx) Then
                nAlpha = ((cy - iY) * 255) \ cx
            Else
                nAlpha = 255
            End If
            
            For iX = 0 To cx - 1
                aPixels(iX, iY) = MakeBGRA((nAlpha * (cx - iX)) \ cx)
            Next iX
        Next iY
    End If
    
    If bRight = 3 Then                                                          'akebe添加
        For iY = 0 To cy - 1                                                    '在阴影高度里面循环
            
            nAlpha = 255
            
            For iX = 0 To cx - 1                                                '在阴影宽度里面循环
                aPixels(iX, iY) = MakeBGRA((nAlpha * iX) \ cx)
            Next iX
        Next iY
    End If
    
    If bRight = 2 Then                                                          'akebe调整
        For iX = 0 To cx - 1
            If iX < cy Then
                nAlpha = (255 * iX) \ cy
            Else
                nAlpha = 255
            End If
            
            For iY = 0 To cy - 1
                aPixels(iX, iY) = MakeBGRA((nAlpha * iY) \ cy)
            Next iY
        Next iX
    End If
    
    If bRight = 4 Then                                                          'akebe添加
        For iX = 0 To cx - 1
            If iX < cy Then
                nAlpha = (255 * iX) \ cy
            Else
                nAlpha = 255
            End If
            
            For iY = 0 To cy - 1
                aPixels(iX, iY) = MakeBGRA((nAlpha * (cy - iY)) \ cy)
            Next iY
        Next iX
    End If
    
    
    CopyMemory ByVal VarPtrArray(aPixels()), 0&, 4
    
    With bs                                                                     'Setup the blend function 设置混合函数
        .AlphaFormat = AC_SRC_ALPHA                                             'Use the alpha channel for individual pixel transparency使用alpha通道单个像素的透明度
        .BlendFlags = 0
        .BlendOp = AC_SRC_OVER                                                  'Alpha overlay  阿尔法覆盖
        .SourceConstantAlpha = m_Transparency                                   'Alpha transparency for overall transparencyAlpha透明度整体透明度
    End With
    
    pt.X = X                                                                    'Setup the window position and size data设置窗口位置和大小的数据
    pt.Y = Y
    sz.cx = cx
    sz.cy = cy
    
    hDib = SelectObject(DC, hDib)                                               'Select the bitmap into the memory display context选择位图到内存中显示上下文
    UpdateLayeredWindow hWin, DC, pt, sz, DC, pt0, 0, bs, ULW_ALPHA             'Do the layered update分层更新
    SelectObject DC, hDib                                                       'Trash the bitmap 垃圾的位图
    DeleteDC DC                                                                 'Delete the memory display context 删除内存显示上下文
End Sub

'Return whether the Luna theme is active 返回Luna主题是否活跃
Private Function IsLuna() As Boolean
    Dim hLib   As Long
    Dim nPos   As Long
    Dim sTheme As String
    Dim sName  As String
    
    hLib = LoadLibraryA("uxtheme.dll")
    
    If hLib <> 0 Then
        sTheme = String$(255, 0)
        
        GetCurrentThemeName StrPtr(sTheme), Len(sTheme), 0, 0, 0, 0
        nPos = InStr(1, sTheme, vbNullChar)
        
        If nPos > 0 Then
            sTheme = Left$(sTheme, nPos - 1)
            sName = String$(255, 0)
            
            GetThemeDocumentationProperty StrPtr(sTheme), StrPtr("ThemeName"), StrPtr(sName), Len(sName)
            nPos = InStr(1, sName, vbNullChar)
            
            If nPos > 0 Then
                sName = Left$(sName, nPos - 1)
                bIsLuna = (StrComp(sName, "Luna", vbTextCompare) = 0)
            End If
        End If
        
        FreeLibrary hLib
    End If
End Function

'Pre-multiply the shadow color with the passed alpha value. This is needed to get nice looking colors according to MSDN.
'　“Pre-multiply阴影颜色传递的alpha值。这是需要根据MSDN好看的颜色
Private Function MakeBGRA(ByVal Alpha As Byte) As Long
    Dim fFactor As Double
    Dim BGRA    As tBGRA
    
    fFactor = CDbl(Alpha) / 255#                                                'Calculate the factor计算系数
    '的注意,nColor RGB格式,这个过程的一部分是BGRA格式转换
    'Note that nColor is in RGB format, part of this process is to convert to BGRA format
    With BGRA                                                                   'Blue, Green, Red, Alpha'蓝色,绿色,红色,阿尔法
        .Blue = ((m_Color And &HFF0000) \ &H10000) * fFactor                    'Factor the blue component
        .Green = ((m_Color And &HFF00&) \ &H100&) * fFactor                     'Factor the green component
        .Red = (m_Color And &HFF) * fFactor                                     'Factor the red component
        .Alpha = Alpha                                                          'Store the alpha value
    End With
    
    'Copy the BGRA type to long复制BGRA类型长
    CopyMemory MakeBGRA, BGRA, 4
End Function

'Show/hide the shadow windows显示/隐藏影子窗口
Private Sub Show(ByVal bShow As Boolean, Optional ByVal bForce As Boolean = False)
    If Not bForce Then
        If bLastShow = bShow Then
            Exit Sub
        End If
    End If
    
    bLastShow = bShow
    
    If bShow Then
        ShowWindow hWndRt, SW_SHOWNOACTIVATE
        ShowWindow hWndBt, SW_SHOWNOACTIVATE
        ShowWindow hWndTt, SW_SHOWNOACTIVATE                                    '(akebe)
        ShowWindow hWndLt, SW_SHOWNOACTIVATE                                    '(akebe)
    Else
        ShowWindow hWndRt, SW_HIDE
        ShowWindow hWndBt, SW_HIDE
        ShowWindow hWndLt, SW_HIDE                                              '(akebe)
        ShowWindow hWndTt, SW_HIDE                                              '(akebe)
    End If
End Sub

'Size/position the shadows 阴影大小/位置
Private Sub SizePos()
    With wp
        If .flags And SWP_HIDEWINDOW Then                                       'If the parent form is being hidden 如果父窗体被隐藏
            Show False                                                          'Hide the shadow windows also 隐藏的影子windows
            
        Else
            If .cx <> cx Then                                                   'If the parent's width has changed 如果父母的宽度已经改变了
                cx = .cx                                                        'Store the new width “存储新的宽度
                DisplayShadowSub .X, .Y + .cy, .cx + m_Depth, m_Depth, 2        '创建窗体大小的阴影(2下)
                DisplayShadowSub .X, .Y + .cy, .cx + m_Depth, m_Depth, 4        '创建窗体大小的阴影(4上)akebe
            End If
            
            If .cy <> cy Then                                                   'If the parent's height has changed 如果父母的身高已经改变了
                cy = .cy                                                        'Store the new height 存储新的高度
                DisplayShadowSub .X + .cx, .Y, m_Depth, .cy + m_Depth + m_Depth, 1 '创建窗体大小的阴影(1右)
                DisplayShadowSub .X + .cx, .Y, m_Depth, .cy + m_Depth + m_Depth, 3 '创建窗体大小的阴影(3左)akebe
            End If
            
            
            MoveWindow hWndRt, .X + .cx, .Y - m_Depth, m_Depth, .cy + m_Depth + m_Depth, False '拷贝阴影窗体到指定位置 右部
            MoveWindow hWndBt, .X - m_Depth, .Y + .cy, .cx + m_Depth, m_Depth, False '拷贝阴影窗体到指定位置 下
            
            MoveWindow hWndTt, .X - m_Depth, .Y, m_Depth, .cy, False            '拷贝阴影窗体到指定位置（akebe）左边
            MoveWindow hWndLt, .X - m_Depth, .Y - m_Depth, .cx + m_Depth, m_Depth, False '拷贝阴影窗体到指定位置（akebe）上边
            
            If (.flags And SWP_SHOWWINDOW) Then
                Show True
            End If
        End If
    End With
End Sub

'-SelfSub codeSelfSub代码------------------------------------------------------------------------------------
Private Function sc_Subclass(ByVal lng_hWnd As Long, _
    Optional ByVal lParamUser As Long = 0, _
    Optional ByVal nOrdinal As Long = 1, _
    Optional ByVal oCallback As Object = Nothing, _
    Optional ByVal bIdeSafety As Boolean = True) As Boolean                     'Subclass the specified window handle 子类指定的窗口句柄
    '*************************************************************************************************
    '* lng_hWnd   - Handle of the window to subclass
    '* lParamUser - Optional, user-defined callback parameter
    '* nOrdinal   - Optional, ordinal index of the callback procedure. 1 = last private method, 2 = second last private method, etc.
    '* oCallback  - Optional, the object that will receive the callback. If undefined, callbacks are sent to this object's instance
    '* bIdeSafety - Optional, enable/disable IDE safety measures. NB: you should really only disable IDE safety in a UserControl for design-time subclassing
    '* lng_hWnd――处理窗口的子类
    '* lParamUser -可选,用户定义的回调参数
    '* nOrdinal -可选,序数指数的回调过程。1 =去年私有方法,2 =第二最后一个私有方法,等等。
    '* oCallback -可选的,将得到的对象回调。如果未定义,回调被发送到该对象的实例
    '* bIdeSafety -可选,启用/禁用IDE的安全措施。注:您真的应该只有禁用IDE安全在一个用户控件设计时
    
    '*************************************************************************************************
    Const CODE_LEN      As Long = 260                                           'Thunk length in bytes铛在字节长度
    Const MEM_LEN       As Long = CODE_LEN + (8 * (MSG_ENTRIES + 1))            'Bytes to allocate per thunk, data + code + msg tables 每铛字节分配,数据+代码+味精表
    Const PAGE_RWX      As Long = &H40&                                         'Allocate executable memory分配可执行的内存
    Const MEM_COMMIT    As Long = &H1000&                                       'Commit allocated memory提交分配的内存
    Const MEM_RELEASE   As Long = &H8000&                                       'Release allocated memory flag释放分配的内存国旗
    Const IDX_EBMODE    As Long = 3                                             'Thunk data index of the EbMode function address铛数据索引EbMode函数的地址
    Const IDX_CWP       As Long = 4                                             'Thunk data index of the CallWindowProc function address 铛数据索引CallWindowProc函数的地址
    Const IDX_SWL       As Long = 5                                             'Thunk data index of the SetWindowsLong function address铛数据索引SetWindowsLong函数的地址
    Const IDX_FREE      As Long = 6                                             'Thunk data index of the VirtualFree function address 铛数据索引VirtualFree函数的地址
    Const IDX_BADPTR    As Long = 7                                             'Thunk data index of the IsBadCodePtr function address 铛数据索引IsBadCodePtr函数的地址
    Const IDX_OWNER     As Long = 8                                             'Thunk data index of the Owner object's vTable address 铛所有者对象的数据索引的vTable地址
    Const IDX_CALLBACK  As Long = 10                                            'Thunk data index of the callback method address铛回调方法的数据索引地址
    Const IDX_EBX       As Long = 16                                            'Thunk code patch index of the thunk data铛铛的代码补丁索引数据
    Const SUB_NAME      As String = "sc_Subclass"                               'This routine's name 这个例程的名称
    Dim nAddr         As Long
    Dim nID           As Long
    Dim nMyID         As Long
    
    If IsWindow(lng_hWnd) = 0 Then                                              'Ensure the window handle is valid 确保窗口句柄是有效的
        zError SUB_NAME, "Invalid window handle"
        Exit Function
    End If
    
    nMyID = GetCurrentProcessId                                                 'Get this process's ID 得到这个进程的ID
    GetWindowThreadProcessId lng_hWnd, nID                                      'Get the process ID associated with the window handle 得到窗口句柄关联的进程ID
    If nID <> nMyID Then                                                        'Ensure that the window handle doesn't belong to another process确保窗口句柄不属于另一个进程
        zError SUB_NAME, "Window handle belongs to another process"
        Exit Function
    End If
    
    If oCallback Is Nothing Then                                                'If the user hasn't specified the callback owner如果用户没有指定回调的所有者
        Set oCallback = Me                                                      'Then it is me然后这是我
    End If
    
    nAddr = zAddressOf(oCallback, nOrdinal)                                     'Get the address of the specified ordinal method获得指定的地址顺序的方法
    If nAddr = 0 Then                                                           'Ensure that we've found the ordinal method确保我们发现顺序的方法
        zError SUB_NAME, "Callback method not found"
        Exit Function
    End If
    
    If z_Funk Is Nothing Then                                                   'If this is the first time through, do the one-time initialization如果这是第一次通过,一次性初始化
        Set z_Funk = New Collection                                             'Create the hWnd/thunk-address collection创建hWnd / thunk-address集合
        z_Sc(14) = &HD231C031: z_Sc(15) = &HBBE58960: z_Sc(17) = &H4339F631: z_Sc(18) = &H4A21750C: z_Sc(19) = &HE82C7B8B: z_Sc(20) = &H74&: z_Sc(21) = &H75147539: z_Sc(22) = &H21E80F: z_Sc(23) = &HD2310000: z_Sc(24) = &HE8307B8B: z_Sc(25) = &H60&: z_Sc(26) = &H10C261: z_Sc(27) = &H830C53FF: z_Sc(28) = &HD77401F8: z_Sc(29) = &H2874C085: z_Sc(30) = &H2E8&: z_Sc(31) = &HFFE9EB00: z_Sc(32) = &H75FF3075: z_Sc(33) = &H2875FF2C: z_Sc(34) = &HFF2475FF: z_Sc(35) = &H3FF2473: z_Sc(36) = &H891053FF: z_Sc(37) = &HBFF1C45: z_Sc(38) = &H73396775: z_Sc(39) = &H58627404
        z_Sc(40) = &H6A2473FF: z_Sc(41) = &H873FFFC: z_Sc(42) = &H891453FF: z_Sc(43) = &H7589285D: z_Sc(44) = &H3045C72C: z_Sc(45) = &H8000&: z_Sc(46) = &H8920458B: z_Sc(47) = &H4589145D: z_Sc(48) = &HC4836124: z_Sc(49) = &H1862FF04: z_Sc(50) = &H35E30F8B: z_Sc(51) = &HA78C985: z_Sc(52) = &H8B04C783: z_Sc(53) = &HAFF22845: z_Sc(54) = &H73FF2775: z_Sc(55) = &H1C53FF28: z_Sc(56) = &H438D1F75: z_Sc(57) = &H144D8D34: z_Sc(58) = &H1C458D50: z_Sc(59) = &HFF3075FF: z_Sc(60) = &H75FF2C75: z_Sc(61) = &H873FF28: z_Sc(62) = &HFF525150: z_Sc(63) = &H53FF2073: z_Sc(64) = &HC328&
        
        z_Sc(IDX_CWP) = zFnAddr("user32", "CallWindowProcA")                    'Store CallWindowProc function address in the thunk data存储在铛CallWindowProc函数地址数据
        z_Sc(IDX_SWL) = zFnAddr("user32", "SetWindowLongA")                     'Store the SetWindowLong function address in the thunk data存储在铛SetWindowLong函数地址数据
        z_Sc(IDX_FREE) = zFnAddr("kernel32", "VirtualFree")                     'Store the VirtualFree function address in the thunk data存储在铛VirtualFree函数地址数据
        z_Sc(IDX_BADPTR) = zFnAddr("kernel32", "IsBadCodePtr")                  'Store the IsBadCodePtr function address in the thunk data存储在铛IsBadCodePtr函数地址数据
    End If
    
    z_ScMem = VirtualAlloc(0, MEM_LEN, MEM_COMMIT, PAGE_RWX)                    'Allocate executable memory分配可执行的内存
    
    If z_ScMem <> 0 Then                                                        'Ensure the allocation succeeded确保配置成功了
        On Error GoTo CatchDoubleSub                                            'Catch double subclassing 捉双子类化
        z_Funk.Add z_ScMem, "h" & lng_hWnd                                      'Add the hWnd/thunk-address to the collection hWnd / thunk-address添加到集合中
        On Error GoTo 0
        
        If bIdeSafety Then                                                      'If the user wants IDE protection 如果用户希望IDE的保护
            z_Sc(IDX_EBMODE) = zFnAddr("vba6", "EbMode")                        'Store the EbMode function address in the thunk data 存储在铛EbMode函数地址数据
        End If
        
        z_Sc(IDX_EBX) = z_ScMem                                                 'Patch the thunk data address 补丁铛数据地址
        z_Sc(IDX_HWND) = lng_hWnd                                               'Store the window handle in the thunk data 商店的窗口句柄铛数据
        z_Sc(IDX_BTABLE) = z_ScMem + CODE_LEN                                   'Store the address of the before table in the thunk data 铛之前存储的地址表的数据
        z_Sc(IDX_ATABLE) = z_ScMem + CODE_LEN + ((MSG_ENTRIES + 1) * 4)         'Store the address of the after table in the thunk data  商店的地址表后铛数据
        z_Sc(IDX_OWNER) = ObjPtr(oCallback)                                     'Store the callback owner's object address in the thunk data 商店老板回调对象地址的铛数据
        z_Sc(IDX_CALLBACK) = nAddr                                              'Store the callback address in the thunk data 存储铛的回调地址数据
        z_Sc(IDX_PARM_USER) = lParamUser                                        'Store the lParamUser callback parameter in the thunk data 存储铛lParamUser回调参数数据
        
        nAddr = SetWindowLongA(lng_hWnd, GWL_WNDPROC, z_ScMem + WNDPROC_OFF)    'Set the new WndProc, return the address of the original WndProc 设置新的指向,返回原始指向的地址
        If nAddr = 0 Then                                                       'Ensure the new WndProc was set correctly 确保新的指向正确设置
            zError SUB_NAME, "SetWindowLong failed, error #" & Err.LastDllError
            GoTo ReleaseMemory
        End If
        
        z_Sc(IDX_WNDPROC) = nAddr                                               'Store the original WndProc address in the thunk data 铛数据存储原始指向地址
        RtlMoveMemory z_ScMem, VarPtr(z_Sc(0)), CODE_LEN                        'Copy the thunk code/data to the allocated memory 复制铛代码/数据分配的内存
        sc_Subclass = True                                                      'Indicate success 显示成功
    Else
        zError SUB_NAME, "VirtualAlloc failed, error: " & Err.LastDllError
    End If
    
    Exit Function                                                               'Exit sc_Subclass 退出sc_Subclass
    
CatchDoubleSub:
    zError SUB_NAME, "Window handle is already subclassed"
    
ReleaseMemory:
    VirtualFree z_ScMem, 0, MEM_RELEASE                                         'sc_Subclass has failed after memory allocation, so release the memory sc_Subclass没有内存分配后,释放内存
End Function

'Terminate all subclassing 终止所有子类化
Private Sub sc_Terminate()
    Dim i As Long
    
    If Not (z_Funk Is Nothing) Then                                             'Ensure that subclassing has been started 确保子类化已经启动
        With z_Funk
            For i = .Count To 1 Step -1                                         'Loop through the collection of window handles in reverse order 遍历集合用倒序的窗口句柄
                z_ScMem = .item(i)                                              'Get the thunk address 铛的地址
                If IsBadCodePtr(z_ScMem) = 0 Then                               'Ensure that the thunk hasn't already released its memory 确保铛没有已经发布了记忆
                    sc_UnSubclass zData(IDX_HWND)                               'UnSubclass
                End If
            Next i                                                              'Next member of the collection 下一个集合的成员
        End With
        Set z_Funk = Nothing                                                    'Destroy the hWnd/thunk-address collection 摧毁hWnd / thunk-address集合
    End If
End Sub

'UnSubclass the specified window handle UnSubclass指定的窗口句柄
Private Sub sc_UnSubclass(ByVal lng_hWnd As Long)
    If z_Funk Is Nothing Then                                                   'Ensure that subclassing has been started 确保子类化已经启动
        zError "sc_UnSubclass", "Window handle isn't subclassed"
    Else
        If IsBadCodePtr(zMap_hWnd(lng_hWnd)) = 0 Then                           'Ensure that the thunk hasn't already released its memory 确保铛没有已经发布了记忆
            zData(IDX_SHUTDOWN) = -1                                            'Set the shutdown indicator 设置关闭指示器
            zDelMsg ALL_MESSAGES, IDX_BTABLE                                    'Delete all before messages 之前删除所有消息
            zDelMsg ALL_MESSAGES, IDX_ATABLE                                    'Delete all after messages 删除所有消息后
        End If
        z_Funk.Remove "h" & lng_hWnd                                            'Remove the specified window handle from the collection 从集合中移除指定的窗口句柄
    End If
End Sub

'Add the message value to the window handle's specified callback table 添加消息的窗口句柄的值指定回调表
Private Sub sc_AddMsg(ByVal lng_hWnd As Long, ByVal uMsg As Long, Optional ByVal When As eMsgWhen = eMsgWhen.MSG_AFTER)
    If IsBadCodePtr(zMap_hWnd(lng_hWnd)) = 0 Then                               'Ensure that the thunk hasn't already released its memory 确保铛没有已经发布了记忆
        If When And MSG_BEFORE Then                                             'If the message is to be added to the before original WndProc table... 如果消息之前添加到原始指向表……
            zAddMsg uMsg, IDX_BTABLE                                            'Add the message to the before table 之前将信息添加到表中
        End If
        If When And MSG_AFTER Then                                              'If message is to be added to the after original WndProc table... 如果消息被添加到原始指向表后……
            zAddMsg uMsg, IDX_ATABLE                                            'Add the message to the after table ”后将消息添加到表中
        End If
    End If
End Sub

'Delete the message value from the window handle's specified callback table 删除消息窗口句柄的值指定回调表
Private Sub sc_DelMsg(ByVal lng_hWnd As Long, ByVal uMsg As Long, Optional ByVal When As eMsgWhen = eMsgWhen.MSG_AFTER)
    If IsBadCodePtr(zMap_hWnd(lng_hWnd)) = 0 Then                               'Ensure that the thunk hasn't already released its memory 确保铛没有已经发布了记忆
        If When And MSG_BEFORE Then                                             'If the message is to be deleted from the before original WndProc table... 如果消息是要从原始指向前表中删除…
            zDelMsg uMsg, IDX_BTABLE                                            'Delete the message from the before table 删除表之前的消息
        End If
        If When And MSG_AFTER Then                                              'If the message is to be deleted from the after original WndProc table... 如果要删除的消息后从最初指向表……
            zDelMsg uMsg, IDX_ATABLE                                            'Delete the message from the after table 删除后表的信息
        End If
    End If
End Sub

'Call the original WndProc 调用原始的指向
Private Function sc_CallOrigWndProc(ByVal lng_hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    If IsBadCodePtr(zMap_hWnd(lng_hWnd)) = 0 Then                               'Ensure that the thunk hasn't already released its memory 确保铛没有已经发布了记忆
        sc_CallOrigWndProc = _
        CallWindowProcA(zData(IDX_WNDPROC), lng_hWnd, uMsg, wParam, lParam)     'Call the original WndProc of the passed window handle parameter 调用的原始指向窗口句柄参数传递
    End If
End Function

'Get the subclasser lParamUser callback parameter 得到subclasser lParamUser回调参数
Private Property Get sc_lParamUser(ByVal lng_hWnd As Long) As Long
    If IsBadCodePtr(zMap_hWnd(lng_hWnd)) = 0 Then                               'Ensure that the thunk hasn't already released its memory 确保铛没有已经发布了记忆
        sc_lParamUser = zData(IDX_PARM_USER)                                    'Get the lParamUser callback parameter lParamUser回调参数
    End If
End Property

'Let the subclasser lParamUser callback parameter 让subclasser lParamUser回调参数
Private Property Let sc_lParamUser(ByVal lng_hWnd As Long, ByVal NewValue As Long)
    If IsBadCodePtr(zMap_hWnd(lng_hWnd)) = 0 Then                               'Ensure that the thunk hasn't already released its memory 确保铛没有已经发布了记忆
        zData(IDX_PARM_USER) = NewValue                                         'Set the lParamUser callback parameter 设置lParamUser回调参数
    End If
End Property

'-The following routines are exclusively for the sc_ subclass routines----------------------------专门为sc_子类以下例程程序

'Add the message to the specified table of the window handle 添加消息到指定表的窗口句柄
Private Sub zAddMsg(ByVal uMsg As Long, ByVal nTable As Long)
    Dim nCount As Long                                                          'Table entry count 表条目数
    Dim nBase  As Long                                                          'Remember z_ScMem 记得z_ScMem
    Dim i      As Long                                                          'Loop index 循环索引
    
    nBase = z_ScMem                                                             'Remember z_ScMem so that we can restore its value on exit 记得z_ScMem退出,这样我们就能恢复其价值
    z_ScMem = zData(nTable)                                                     'Map zData() to the specified table 地图zData()指定的表
    
    If uMsg = ALL_MESSAGES Then                                                 'If ALL_MESSAGES are being added to the table... 如果ALL_MESSAGES被添加到表……
        nCount = ALL_MESSAGES                                                   'Set the table entry count to ALL_MESSAGES 设置表条目数到ALL_MESSAGES
    Else
        nCount = zData(0)                                                       'Get the current table entry count 获取当前的表条目数
        If nCount >= MSG_ENTRIES Then                                           'Check for message table overflow 检查信息表溢出
            zError "zAddMsg", "Message table overflow. Either increase the value of Const MSG_ENTRIES or use ALL_MESSAGES instead of specific message values"
            GoTo Bail
        End If
        
        For i = 1 To nCount                                                     'Loop through the table entries 遍历表条目
            If zData(i) = 0 Then                                                'If the element is free... 如果元素是免费的…
                zData(i) = uMsg                                                 'Use this element 使用这个元素
                GoTo Bail                                                       'Bail 保释
            ElseIf zData(i) = uMsg Then                                         'If the message is already in the table... 如果消息已经在桌子上……
                GoTo Bail                                                       'Bail  保释
            End If
        Next i                                                                  'Next message table entry 下一个信息表条目
        
        nCount = i                                                              'On drop through: i = nCount + 1, the new table entry count 在下降:我= nCount + 1,新表条目数
        zData(nCount) = uMsg                                                    'Store the message in the appended table entry 存储消息附加表中的条目
    End If
    
    zData(0) = nCount                                                           'Store the new table entry count 存储新的表条目数
Bail:
    z_ScMem = nBase                                                             'Restore the value of z_ScMem 恢复z_ScMem的价值
End Sub

'Delete the message from the specified table of the window handle从指定表删除消息的窗口句柄
Private Sub zDelMsg(ByVal uMsg As Long, ByVal nTable As Long)
    Dim nCount As Long                                                          'Table entry count表条目数
    Dim nBase  As Long                                                          'Remember z_ScMem记得z_ScMem
    Dim i      As Long                                                          'Loop index循环索引
    
    nBase = z_ScMem                                                             'Remember z_ScMem so that we can restore its value on exit 记得z_ScMem退出,这样我们就能恢复其价值
    z_ScMem = zData(nTable)                                                     'Map zData() to the specified table 地图zData()指定的表
    
    If uMsg = ALL_MESSAGES Then                                                 'If ALL_MESSAGES are being deleted from the table...如果ALL_MESSAGES正在从表中删除…
        zData(0) = 0                                                            'Zero the table entry count零表条目数
    Else
        nCount = zData(0)                                                       'Get the table entry count表条目数
        
        For i = 1 To nCount                                                     'Loop through the table entries遍历表条目
            If zData(i) = uMsg Then                                             'If the message is found... 如果找到的消息……
                zData(i) = 0                                                    'Null the msg value -- also frees the element for re-use 空味精价值――也使重用的元素
                GoTo Bail                                                       'Bail保释
            End If
        Next i                                                                  'Next message table entry下一个信息表条目
        
        zError "zDelMsg", "Message &H" & Hex$(uMsg) & " not found in table"
    End If
    
Bail:
    z_ScMem = nBase                                                             'Restore the value of z_ScMem恢复z_ScMem的价值
End Sub

'Error handler错误处理程序
Private Sub zError(ByVal sRoutine As String, ByVal sMsg As String)
    App.LogEvent TypeName(Me) & "." & sRoutine & ": " & sMsg, vbLogEventTypeError
    MsgBox sMsg & ".", vbExclamation + vbApplicationModal, "Error in " & TypeName(Me) & "." & sRoutine
End Sub

'Return the address of the specified DLL/procedure返回指定DLL的地址/过程
Private Function zFnAddr(ByVal sDLL As String, ByVal sProc As String) As Long
    zFnAddr = GetProcAddress(GetModuleHandleA(sDLL), sProc)                     'Get the specified procedure address 获取指定程序的地址
    Debug.Assert zFnAddr                                                        'In the IDE, validate that the procedure address was located 在IDE中,验证程序的地址
End Function

'Map zData() to the thunk address for the specified window handle 地图zData()的铛地址指定的窗口句柄
Private Function zMap_hWnd(ByVal lng_hWnd As Long) As Long
    If z_Funk Is Nothing Then                                                   'Ensure that subclassing has been started确保子类化已经启动
        zError "zMap_hWnd", "Subclassing hasn't been started"
    Else
        On Error GoTo Catch                                                     'Catch unsubclassed window handles抓住unsubclassed窗口句柄
        z_ScMem = z_Funk("h" & lng_hWnd)                                        'Get the thunk address“铛地址
        zMap_hWnd = z_ScMem
    End If
    
    Exit Function                                                               'Exit returning the thunk address退出返回铛的地址
    
Catch:
    zError "zMap_hWnd", "Window handle isn't subclassed"
End Function

'Return the address of the specified ordinal method on the oCallback object, 1 = last private method, 2 = second last private method, etc
'返回指定的地址顺序方法oCallback对象,1 =去年私有方法,2 =第二最后一个私有方法,等等
Private Function zAddressOf(ByVal oCallback As Object, ByVal nOrdinal As Long) As Long
    Dim bSub  As Byte                                                           'Value we expect to find pointed at by a vTable method entry我们希望找到价值指向的vTable方法条目
    Dim bVal  As Byte
    Dim nAddr As Long                                                           'Address of the vTable地址的vTable
    Dim i     As Long                                                           'Loop index循环索引
    Dim j     As Long                                                           'Loop limit 循环的限制
    
    RtlMoveMemory VarPtr(nAddr), ObjPtr(oCallback), 4                           'Get the address of the callback object's instance获得地址回调对象的实例
    If Not zProbe(nAddr + &H1C, i, bSub) Then                                   'Probe for a Class method类方法的调查
        If Not zProbe(nAddr + &H6F8, i, bSub) Then                              'Probe for a Form method探究一种方法
            If Not zProbe(nAddr + &H7A4, i, bSub) Then                          'Probe for a UserControl method调查用户控件的方法
                Exit Function                                                   'Bail... 保释……
            End If
        End If
    End If
    
    i = i + 4                                                                   'Bump to the next entry 撞到下一个条目
    j = i + 1024                                                                'Set a reasonable limit, scan 256 vTable entries设置一个合理的限制,扫描256 vTable条目
    Do While i < j
        RtlMoveMemory VarPtr(nAddr), i, 4                                       'Get the address stored in this vTable entry 获得地址存储在这个虚表条目
        
        If IsBadCodePtr(nAddr) Then                                             'Is the entry an invalid code address? 输入一个无效的代码地址吗?
            RtlMoveMemory VarPtr(zAddressOf), i - (nOrdinal * 4), 4             'Return the specified vTable entry address 返回指定的vTable入口地址
            Exit Do                                                             'Bad method signature, quit loop 坏方法签名,退出循环
        End If
        
        RtlMoveMemory VarPtr(bVal), nAddr, 1                                    'Get the byte pointed to by the vTable entry 获得的字节指着vTable条目
        If bVal <> bSub Then                                                    'If the byte doesn't match the expected value... 如果字节不匹配预期的值…
            RtlMoveMemory VarPtr(zAddressOf), i - (nOrdinal * 4), 4             'Return the specified vTable entry address 返回指定的vTable入口地址
            Exit Do                                                             'Bad method signature, quit loop 坏方法签名,退出循环
        End If
        
        i = i + 4                                                               '下一个虚表条目
        
    Loop
End Function

'Probe at the specified start address for a method signature指定起始地址探测方法签名
Private Function zProbe(ByVal nStart As Long, ByRef nMethod As Long, ByRef bSub As Byte) As Boolean
    Dim bVal    As Byte
    Dim nAddr   As Long
    Dim nLimit  As Long
    Dim nEntry  As Long
    
    nAddr = nStart                                                              'Start address 起始地址
    nLimit = nAddr + 32                                                         'Probe eight entries调查八个条目
    Do While nAddr < nLimit                                                     'While we've not reached our probe depth虽然我们没有达到探测深度
        RtlMoveMemory VarPtr(nEntry), nAddr, 4                                  'Get the vTable entry 得到vTable条目
        
        If nEntry <> 0 Then                                                     'If not an implemented interface如果没有一个实现接口
            RtlMoveMemory VarPtr(bVal), nEntry, 1                               'Get the value pointed at by the vTable entry 获得的价值指向vTable条目
            If bVal = &H33 Or bVal = &HE9 Then                                  'Check for a native or pcode method signature检查本机或pcode方法签名
                nMethod = nAddr                                                 'Store the vTable entry存储vTable条目
                bSub = bVal                                                     'Store the found method signature 存储方法签名
                zProbe = True                                                   'Indicate success 显示成功
                Exit Function                                                   'Return 返回
            End If
        End If
        
        nAddr = nAddr + 4                                                       'Next vTable entry 下一个虚表条目
    Loop
End Function

Private Property Get zData(ByVal nIndex As Long) As Long
    RtlMoveMemory VarPtr(zData), z_ScMem + (nIndex * 4), 4
End Property

Private Property Let zData(ByVal nIndex As Long, ByVal nValue As Long)
    RtlMoveMemory z_ScMem + (nIndex * 4), VarPtr(nValue), 4
End Property

'-Subclass callback, usually ordinal #1, the last method in this source file----------------------子类的回调,通常序数# 1,最后一个方法在这个源文件-
Private Sub zWndProc1(ByVal bBefore As Boolean, _
    ByRef bHandled As Boolean, _
    ByRef lReturn As Long, _
    ByVal lng_hWnd As Long, _
    ByVal uMsg As Long, _
    ByVal wParam As Long, _
    ByVal lParam As Long, _
    ByRef lParamUser As Long)
    '*************************************************************************************************
    '* bBefore    - Indicates whether the callback is before or after the original WndProc. Usually
    '*              you will know unless the callback for the uMsg value is specified as
    '*              MSG_BEFORE_AFTER (both before and after the original WndProc).
    '* bHandled   - In a before original WndProc callback, setting bHandled to True will prevent the
    '*              message being passed to the original WndProc and (if set to do so) the after
    '*              original WndProc callback.
    '* lReturn    - WndProc return value. Set as per the MSDN documentation for the message value,
    '*              and/or, in an after the original WndProc callback, act on the return value as set
    '*              by the original WndProc.
    '* lng_hWnd   - Window handle.
    '* uMsg       - Message value.
    '* wParam     - Message related data.
    '* lParam     - Message related data.
    '* lParamUser - User-defined callback parameter
    
    '* bBefore:表示之前或之后的回调是否最初的指向。通常
    '*你就会知道,除非uMsg值被指定为回调
    '* MSG_BEFORE_AFTER(之前和之后都原始的指向)。
    '* bHandled――在原始指向回调之前,将bHandled设置为True会阻止
    '*消息被传递到原始指向和(如果设置)之后
    '*原始指向回调。
    '* lReturn――指向返回值。设置为每MSDN文档信息的价值,
    '*和/或在原指向回调后,返回值的设置
    '*由原来的指向。
    '* lng_hWnd -窗口句柄。
    '* uMsg――消息值。
    '*按钮――消息相关的数据。
    '* lParam――消息相关的数据。
    '* lParamUser――用户定义的回调参数
    
    
    '*************************************************************************************************
    Dim tLayered As Boolean
    
    If uMsg = WM_WINDOWPOSCHANGED Then                                          'Select the message number 选择消息数量
        CopyMemory wp, ByVal lParam, Len(wp)                                    'Copy the WINDOWPOS data复制WINDOWPOS数据
        SizePos                                                                 'Position shadows位置的阴影
        
    ElseIf uMsg = WM_SIZE Then                                                  'Parent form has been minimized/restored/maximized 父窗体最小化/恢复/最大化
        If wParam = SIZE_RESTORED Then                                          'If the parent has been restored 如果父母已经恢复
            If IsWindowVisible(hWndForm) = 1 Then                               'If the parent is visible 如果父母是可见的
                Show True                                                       'Show shadows 显示阴影
            End If
        End If
        
    ElseIf uMsg = WM_DISPLAYCHANGE Then                                         'The display settings have been changed 显示设置已经改变了
        tLayered = bIsLayered                                                   'Save the the existing layered status 保存现有的分层状态
        CheckEnvironment                                                        'Check OS, color depth etc. 检查操作系统、颜色深度等。
        If tLayered Then                                                        'If we were layer enabled如果我们层启用
            If Not bIsLayered Then                                              'But not anymore但现在已经不是了
                DestroyWindow hWndBt                                            'Get rid of the shadow 摆脱阴影
                DestroyWindow hWndRt                                            'Get rid of the shadow摆脱阴影
                DestroyWindow hWndTt                                            'Get rid of the shadow摆脱阴影(AKEBE)
                DestroyWindow hWndLt                                            'Get rid of the shadow摆脱阴影(AKEBE)
            End If
        Else
            If bIsLayered Then                                                  'If we're now layered but previously weren't如果我们现在分层,但以前没有
                CreateWindows                                                   'Creates the shadow windows 创建阴影窗户
                DisplayShadows                                                  'Display the shadows 显示阴影
                If IsWindowVisible(hWndForm) Then                               'If the parent is visible 如果父母是可见的
                    Show True, True                                             'Display the shadows 显示阴影
                End If
            End If
        End If
        
    ElseIf uMsg = WM_THEMECHANGED Then                                          'Windows XP theme has changed Windows XP主题已经改变了
        CheckEnvironment                                                        'Check OS, color depth etc.检查操作系统、颜色深度等。
        DisplayShadows                                                          'Display the shadows 显示阴影
        
        
    End If
    
    
End Sub






