【更改日志】

# 2019.6.22

昨天下午到现在尝试使用管道来获取gdb的输出，经过许多尝试之后总算有点眉目了。代码请见“gdb管道调试测试”文件夹。
一些总结：
1. 看上去管道获取gdb输出是个不错的方式，之后拖控件大法的调试功能就打算这样弄了，通过分析gdb的输出来获取需要的信息
2. “中断程序”功能尚未完善，打算改良运行的方式：先用`CreateProcess`运行并挂起(`CREATE_SUSPENDED`)待调试的程序，然后让gdb附加到这个进程上。这样就可以得到待调试进程的PID和进程句柄，从而使用`DebugBreakProcess`使其中断
3. `NtSuspendProcess`虽然能让待调试进程挂起，但是gdb却仍然认为他在运行，故不采用此方式
潜在问题：
4. 进入gdb之后需要使用`set pagination off`来关闭gdb的"Type <return> to continue, or q <return> to quit"消息

# 2019.6.21

今天早上又研究了一下gdb的调试命令，这些应该能用上：
1. `set variable 【变量名】 = 【新值】` 把指定变量的值更改成【新值】
2. `disassemble 【地址】` 在指定的地址反汇编
3. `continue` 继续执行
4. `tbreak` 设置一个临时断点，可以和`jump 【行号】`配合使用
5. `next` 逐过程执行； `step` 逐语句执行； `nexti` 逐个汇编指令执行
6. `finish` 执行到返回
7. `kill` 杀掉

# 2019.6.20

项目正式开坑！<br>
花了一个下午研究如何用GCC编译带有资源文件的exe。没想到原来没有想象中这么难。大致的步骤如下：<br>
1. 编写好资源文件脚本文件（Resource Script, *.rc）<br>
2. 使用windres对rc进行编译。windres会对rc文件里面涉及到的资源进行收集，所以尽量把里面涉及到的资源与rc文件放在同一目录下。编译命令：`windres --include-dir="【Include路径】" 【输入rc文件】 -O coff -o 【输出res文件】`<br>
3. 使用g++对源码和res文件进行编译。编译命令：`g++ 【源码路径】 【res路径】 -o 【输出exe路径】` 注意：【源码路径】不需要包括.h文件<br>

晚上研究了一下gdb的使用。如果我想要调试某个exe，那么使用g++编译它的时候要加上`-g`参数，使编译的exe能被gdb调试。<br>
接着试了一下gdb的命令行参数，大概是这样使用的（如有错请纠正，毕竟我是今天才开始学习使用的）：`gdb -exec="【需调试程序的路径】" -q -nw` 其中`-q`让gdb不要输出版本信息，`-nw`让gdb使用命令行界面。至于调试命令尚未研究，不过找到个文档，晚点看看：http://condor.depaul.edu/glancast/373class/docs/gdb.html

又研究了好一会儿，发现上面的命令行参数中`-exec="【需调试程序的路径】"`这一部分是多余的，因为即使在命令行中指定了需调试程序的路径之后也要指定。然后我熟悉了一下gdb的一些基本命令：
1. `file "【需调试程序的路径】"` 指定需要调试的程序，并加载符号（symbols）。注意路径里面的右斜杠“\”需要被替换成左斜杠“/”
2. `b 【函数名 或 行号】` 往指定的位置下断点
3. `d` 删除所有断点
4. `p 【表达式】` 非常好用！计算指定的表达式。如`p &a`能显示出变量a的地址
5. `info locals` 显示出本地变量
6. `info stack` 显示堆栈
7. `ptype 【表达式】` 同样非常好用！获取指定表达式的类型。如`ptype a`就能显示出变量a的类型（int等）。<br>

还有很多很多功能不一一罗列了。不得不感叹gdb真的十分强大！
