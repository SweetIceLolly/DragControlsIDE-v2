【日志】

# 2019.7.2

为TabBar控件的Resize事件加了On Error Resume Next，因为有时候调整大小的时候会出错。

添加了管道类，用来获取DOS程序的输出。

添加检测指定进程是否存在的函数：ProcessExists

为frmOutput添加了文本框和OutputLog过程。

为frmPopupMenu的AddItems过程加了On Error Resume Next，暴力解决烦人的“表达式太复杂”错误（编译之后不会这样）。

修复主页面的排版，预留空位给工具栏。

主程序添加“运行”菜单的代码，尝试使用g++进行编译代码框里的代码，并使用管道获取其输出；并运行编译后的程序，用gdb进行附加。目前效果良好，不过尚未编写gdb调试相关的代码。想要试这个功能：新建空白C++程序→打代码→调试菜单→运行。

# ~~2019.6.31~~ 2019.7.1

优化窗口子类化，使其能适用于不同的窗口。窗口先用ObjPtr记录自身Object的地址，子类化通过获取这个Object来卸载窗体。

改进了ImageButton，现在支持图片加文本。

采用优化后的窗口子类化，修复了代码窗体最大化时全屏，以及代码窗体不能通过任务栏关闭的问题。

# 2019.6.30

主工程:

菜单位图现支持PNG。404可以尽情发挥了。

添加资源文件编译需要用到的头文件，路径为GCC\include\res。

极度（找不到适合的词汇）感谢404！！！~~抛弃~~搁置MuingIII，任劳任怨地帮我弄了这个漂亮的TabBar！！

IceControls:

添加了CtlBasic类和IceWindow类（没写多少）。

debug_build.bat:

修改了编译命令，现在会先编译资源文件，再编译exe。

# 2019.6.29

添加了GCC（千万别被上一个commit吓到！绝大部分都是GCC里的头文件！不是我写的2333333）

把ImageButton里的图片改成了PNG控件。

代码框显示了侧边栏，可以按那里下断点。（因为修复了皮肤样式）

添加了大部分需要用到的窗口，不过几乎什么都还没弄。

添加了创建工作区的代码。

主窗口里的客户区里面又多了一个窗口客户区，Pane在客户区里工作，而其他的窗口则在窗口客户区里工作。

添加了项目标识，用来记录当前工程是什么类型。

决定先弄“空白C++文件”的创建，应该不会太难。

菜单项一开始一些会禁用掉，之后会随不同工程的类型而启用不同的菜单项。

# 2019.6.27

创建了主项目工程。

添加了代码框窗口。

去掉了昨天所说的“遮挡用PictureBox”，因为通过修改样式文件修复了风格不一致的问题。

修复了子窗口调整大小不正确的问题。

更改DarkEdit的字体颜色，使其更容易阅读。

精简了一些不必要的样式文件。

应404要求，在工程目录中加入了所有用到的OCX文件。

修复了子窗口最大化后，主窗口大小改变时子窗口大小不随之改变的问题。

修复了窗口不能通过任务栏的右键菜单关闭的问题。

添加了菜单项。

添加了资源文件，该资源文件用于存档字串表，因为软件语言将会有中文和英文。以后程序里的字符串需要从资源文件里读取。

感谢404新添加的一些图标。

# 2019.6.26

修好了窗体最大化的时候全屏的问题。

创建了IceControls工程。该工程是整个项目的核心，负责为每个控件的功能提供接口，并处理每个控件的事件。头文件IceControls.h将采用header-only的方式编写。

添加了代码框。为了让代码框的滚动条能符合风格真的花了好多功夫...好辛苦啊 最后还用PictureBox遮挡了一下改不了的地方（23333）最后的效果还是可以的。

# 2019.6.25

加上了Docking Pane。问题：Pane的控制按钮风格不一致...尚不知道如何修复。

目前在XP上也能运行。

哦对，感谢404再次为UI做出的贡献！Pane控件的配色多亏他了。

# 2019.6.23

再次优化gdb附加进程的整个流程，现在流程如下：
1. 运行并挂起待调试进程；运行gdb
2. `file 【待调试进程】`
3. `set pagination off`
4. `attach 【待调试进程PID】`
5. `continue`

（代码懒得更新了，不过之后会按照这个流程进行）

下午弄了一个窗体的雏形，以后**可能**用这样的窗体。潜在问题：不知道自己以前弄的轮子是否可靠... 但愿可靠吧（23333）
欢迎就UI提出更改建议和意见！

感谢404为UI进行的改良！

# 2019.6.22

昨天下午到现在尝试使用管道来获取gdb的输出，经过许多尝试之后总算有点眉目了。代码请见“gdb管道调试测试”文件夹。
一些总结：
1. 看上去管道获取gdb输出是个不错的方式，之后拖控件大法的调试功能就打算这样弄了，通过分析gdb的输出来获取需要的信息
2. “中断程序”功能尚未完善，打算改良运行的方式：先用`CreateProcess`运行并挂起(`CREATE_SUSPENDED`)待调试的程序，然后让gdb附加到这个进程上。这样就可以得到待调试进程的PID和进程句柄，从而使用`DebugBreakProcess`使其中断
3. `NtSuspendProcess`虽然能让待调试进程挂起，但是gdb却仍然认为他在运行，故不采用此方式
4. 尚未试过gdb附加调试进程，之后会试试

潜在问题：
进入gdb之后需要使用`set pagination off`来关闭gdb的"Type <return> to continue, or q <return> to quit"消息

晚上对管道调试的机制进行了一些改进，现在已经能够基本达到我期望的标准，运行一个程序并对它进行调试。
一些总结：
1. 早上所提到的“中断程序”功能现在已经基本完善，并确实是像上面总结的第2点的思路做的
2. gdb附加调试进程很简单，只需要`attach 【进程ID】`即可

潜在问题：
调试完成之后可能会有残留的gdb进程或者待调试程序的进程，需要手动关闭。之后会想办法处理这些问题。

# 2019.6.21

今天早上又研究了一下gdb的调试命令，这些应该能用上：
1. `set variable 【变量名】 = 【新值】` 把指定变量的值更改成【新值】
2. `disassemble 【地址】` 在指定的地址反汇编
3. `continue` 继续执行
4. `tbreak` 设置一个临时断点，可以和`jump 【行号】`配合使用
5. `next` 逐过程执行； `step` 逐语句执行； `nexti` 逐个汇编指令执行
6. `finish` 执行到返回
7. `kill` 杀掉

# 2019.6.20

项目正式开坑！<br>
花了一个下午研究如何用GCC编译带有资源文件的exe。没想到原来没有想象中这么难。大致的步骤如下：<br>
1. 编写好资源文件脚本文件（Resource Script, *.rc）<br>
2. 使用windres对rc进行编译。windres会对rc文件里面涉及到的资源进行收集，所以尽量把里面涉及到的资源与rc文件放在同一目录下。编译命令：`windres --include-dir="【Include路径】" 【输入rc文件】 -O coff -o 【输出res文件】`<br>
3. 使用g++对源码和res文件进行编译。编译命令：`g++ 【源码路径】 【res路径】 -o 【输出exe路径】` 注意：【源码路径】不需要包括.h文件<br>

晚上研究了一下gdb的使用。如果我想要调试某个exe，那么使用g++编译它的时候要加上`-g`参数，使编译的exe能被gdb调试。<br>
接着试了一下gdb的命令行参数，大概是这样使用的（如有错请纠正，毕竟我是今天才开始学习使用的）：`gdb -exec="【需调试程序的路径】" -q -nw` 其中`-q`让gdb不要输出版本信息，`-nw`让gdb使用命令行界面。至于调试命令尚未研究，不过找到个文档，晚点看看：http://condor.depaul.edu/glancast/373class/docs/gdb.html

又研究了好一会儿，发现上面的命令行参数中`-exec="【需调试程序的路径】"`这一部分是多余的，因为即使在命令行中指定了需调试程序的路径之后也要指定。然后我熟悉了一下gdb的一些基本命令：
1. `file "【需调试程序的路径】"` 指定需要调试的程序，并加载符号（symbols）。注意路径里面的右斜杠“\”需要被替换成左斜杠“/”
2. `b 【函数名 或 行号】` 往指定的位置下断点
3. `d` 删除所有断点
4. `p 【表达式】` 非常好用！计算指定的表达式。如`p &a`能显示出变量a的地址
5. `info locals` 显示出本地变量
6. `info stack` 显示堆栈
7. `ptype 【表达式】` 同样非常好用！获取指定表达式的类型。如`ptype a`就能显示出变量a的类型（int等）。<br>

还有很多很多功能不一一罗列了。不得不感叹gdb真的十分强大！
